# 01|为什么要学习数据结构和算法？

## 终极目标：

- 我们学习任何知识都是为了“用”的，是为了解决实际工作问题的。
- 基础架构研发工程师，写出达到开源水平的框架才是你的目标。

## 好处：

- 掌握了数据结构和算法，你看待问题的深度，解决问题的角度就会完全不一样。

## 框架和源码的关系：

- 在这些基础框架中，一般揉和了很多基础数据结构和算法的设计思想。
- 掌握数据结构和算法，不管对于阅读框架源码，还是理解其背后的设计思想，都是非常有用的。
- 相辅相成的，我们通过看基础框架了解算法应用，我们通过学习算法帮助我们理解框架。

## 课后思考：

### 为什么学习数据结构和算法？

- 学习先进的思想，锻炼逻辑思维
- 更好的理解框架
- 在工作中使用，提供更好的思想

### 数据结构和算法在哪些地方帮到了你？

- 复杂问题的分析
- 解决工作的难点问题



# 02|如何抓住重点，系统高效地学习数据结构和算法？

## 望而却步的原因：没有找到好的学习方法，没有抓住学习的重点

## 概述

- 数据结构就是一组数据的存储结构，算法就是操作数据的一组方法。

- 数据结构是为算法服务的，算法要作用在特定的数据结构之上。

## 学习重点：

- 复杂度分析 -- 数据结构与算法中最重要的概念
- 10个数据结构 -- 数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie树
- 10个算法 -- 递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法

## 学习概念需要掌握的部分

- 学习概念的三个部分：是什么 - 为什么 - 怎么做
- 学习概念的几个方面：来历、自身的特点、适合解决的问题、实际的应用场景

## 学习技巧：

1. 边学边练，适度刷题
2. 多问、多思考、多互动
3. 打怪升级学习法（立切实可行的目标：看完一篇写总结记录，代码实现学到的算法，思考总结用自己话讲出来）
4. 知识需要沉淀，不要想试图一下子掌握所有（学习知识的过程是反复迭代、不断沉淀的过程）-- 学一遍、沉淀、再学习

## 课后思考：打怪升级法的flag

- 看完一篇写总结记录
- 代码时间学到的算法
- 思考总结用自己的话讲出来
- 一周左右复习前面总结的内容
- 平台更上一步



# 03|复杂度分析（上）：如何分析、统计算法的执行效率和资源…

## 核心点：

- 数据结构和算法解决的是“快”和“省”的问题，代码运行得更快，代码更省存储空间》

- 复杂度分析是整个算法学习的精髓，只要掌握了它，数据结构和算法的内容基本上就掌握了一半。

## 为什么需要复杂度分析？

- 事后统计法：通过运行代码观察执行时间和占用内存大小。测试结果非常依赖测试环境，测试结果收数据规模的影响很大。
- 我们需要一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法。

## 大O表示法：

- 所有代码的执行时间T(n)与每行代码的执行次数n成正比（需要再乘以一个每行代码的执行时间unit_time才是真实的所有代码执行时间）
- T(n)=O(f(n))，T(n)表示代码执行的时间，n表示数据规模的大小，f(n)表示每行代码执行的次数总和
- **大O时间复杂度表示法：**实际上并不表示代码真正的的执行时间，而是表示代码执行时间随数据增长的**变化趋势**，所以也叫做**渐进时间复杂度**（asymptotic time complexity），简称时间复杂度

## 时间复杂度分析

### 1. 只关注循环执行次数最多的一段代码

- 我们在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那段代码就可以了

### 2. 加法原则：总复杂度等于两级最大的那段代码的复杂度

- 总的时间复杂度就是等于量级最大的那段代码的时间复杂度

### 3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

- 分析嵌套循环

## 几种常见的时间复杂度实例分析

### 复杂度量级（按数量级递增）

#### 多项式量级：

- 常量阶 O(1)
- 对数阶 O(logn)
- 线性阶 O(n)
- 线性对数阶 O(nlogn)
- 平方阶 O(n<sup>2</sup>) 、立方阶 O(n<sup>3</sup>)  …… k方阶 O(n<sup>k</sup>)

#### 非多项式量级

- 指数阶 O(2<sup>n</sup>)
- 阶乘阶 O(n!)

#### 我们吧时间复杂度为非多项式量级的算法问题叫做NP（Non-Deterministic Polynomial，非确定多项式）问题

### 1. O(1)

- 一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是O(1)

### 2. O(logn)、O(nlogn)

- 2<sup>x</sup> = n，x=log<sub>2</sub>n
- log<sub>3</sub>n = log<sub>3</sub>2 * log<sub>2</sub>n，log<sub>3</sub>2是常数
- 对数阶时间复杂度的标识方法里，忽略对数的底，统一表示为O(logn)
- 一段代码的时间复杂度是O(logn)，我们循环执行n遍，时间复杂度就是O(nlogn)了

### 3. O(m+n)、O(m*n)

- 代码复杂度有**两个数据**的规模来决定，无法评估m和n的数量级大
- T1(m) + T2(n) = O(f(m) + g(n))
- T1(m) * T2(n) = O(f(m) * g(n))

## 空间复杂度分析

- 渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系

- 渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系

## 如何掌握好复杂度分析方法？

- 复杂度分析分析并不难，关键在于多练。

## 课后思考

- 性能测试都是代码完成后进行的，比较靠后
- 只需要核心逻辑做复杂度分析，并不需要每段代码都做



# 04|复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度

## 概念：

- 为了表示代码在不同情况下的不同时间复杂度，我们需要引入三个概念：最好情况时间复杂度、最坏情况时间复杂度和平均情况时间复杂度。

- 最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度。

- 最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度。

- 平均时间复杂度的全称应该叫做加权凭据时间复杂度或者期望时间复杂度。
- 很多时候，我们只使用一个复杂度就可以满足需求了。只有同一块代码在不同的情况下，时间复杂度有数量级的差距，我们才会使用这三种复杂度的表示法来区分。



## 摊还分析法

- 摊还分析得到的时间复杂度叫均摊时间复杂度。
- 一组连续操作中，大部分时间复杂度比较低，只有个别情况下时间复杂度比较高，将这一组操作放在一块分析，看是否能将较高时间的复杂度那次操作的耗时，平摊到其他时间复杂度比较低的操作上面。
- 一般均摊时间复杂度就是最好情况时间复杂度。
- 均摊时间复杂度就是一种特殊的平均时间复杂度。



## 课后思考

add函数

- 最好时间复杂度：O(1)，空间足够的情况

- 最坏时间复杂度：O(n)，空间不够的情况，遍历赋值

- 平均时间复杂度：O(1)

- $$
  1*1/(n+1) + 1*1/(n+1) + ... + (n+1)*1/(n+1)
  = (n + n+1)*1/(n+1)
  = (2n+1)/(n+1) = 2 - 1/(n+1)
  $$

- 均摊时间复杂度：O(1)
  $$
  (n+1)/n = 1 + 1/n
  $$
  

