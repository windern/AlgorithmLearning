# 11|排序（上）：为什么插入排序比冒泡排序更受欢迎？

## 1、排序算法的执行效率（排序性能）

- 最好情况、最坏情况、平均情况时间复杂度。——需要考虑不能数据下的性能表现
- 时间复杂度的系数、常数、低阶——时间复杂度反应的是数据规模n很大的时候增长趋势，实际软件开发中，我们排序的数据可能10-1000这样规模很小的数据，所以对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来
- 比较次数和交换次数（或移动）次数——基于比较的排序算法，都会用到比较、交换操作

## 2、排序算法其他度量指标

- 空间复杂度：原地排序算法，特指控件复杂度为O(1)的排序算法。
- 排序算法的稳定性：如果待排序的序列中存在值相等的袁术，经过排序之后，相等元素之间原有的先后顺序不变。

## 冒泡排序

### 什么是冒泡排序？

- 冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求，如果不满足就让它们互换。
- 一次冒泡会让至少一个元素移动到它应该在的位置。

### 冒泡排序分析：

- 原地排序算法：是
- 稳定排序算法：是
- 最好情况时间复杂度O(n)，最坏时间复杂度O(n<sup>2</sup>)
- 平均时间复杂度：满序度为n\*(n-1)/2，假设平均逆序度为其一半n\*(n-1)/2/2，有一个逆序元素对，就需要一次交换，所以平均情况时间复杂度为O(n<sup>2</sup>)

## 插入排序

### 什么是插入排序？

- 将数组中的数据分为两个区间，已排序区间和未排序区间。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的位置进行插入，并保证已排序区间数据一直有序。
- 移动操作的次数等于逆序度

### 插入排序分析：

- 原地排序算法：是
- 稳定排序算法：是
- 最好时间复杂度：O(n)，最坏时间复杂度O(n<sup>2</sup>)
- 平均时间复杂度：O(n<sup>2</sup>)，插入一个数据的平均时间复杂度是O(n)，重复n次插入，所以为O(n<sup>2</sup>)

## 选择排序

### 什么是选择排序？

- 数据也分为已排序区间和未排序区间。每次从未排序区间中选择最小的元素，放在已排序区间的末尾。
- 每次都选择出最小元素，然后放在已排序区间的末尾，即交换这两个位置。

选择排序分析：

- 原地排序算法：是
- 稳定排序算法：否
- 最好时间复杂度：O(n<sup>2</sup>)，最坏时间复杂度O(n<sup>2</sup>)
- 平均时间复杂度：O(n<sup>2</sup>)

## 开篇问题：

### 插入排序比冒泡排序优

- 冒泡排序不管怎么优化，交换次数都是逆序度
- 插入排序不管怎么优化，元素移动次数都是逆序度
- 但是代码实现，冒泡排序比插入排序实现复杂，冒泡排序需要3次赋值操作，插入排序只需要一个
- 插入排序还可以优化

## 总结：

|          | 是否稳定？ | 原地排序？ | 最好             | 最坏             | 平均             |
| -------- | ---------- | ---------- | ---------------- | ---------------- | ---------------- |
| 冒泡排序 | ✔️          | ✔️          | O(1)             | O(n<sup>2</sup>) | O(n<sup>2</sup>) |
| 插入排序 | ✔️          | ✔️          | O(1)             | O(n<sup>2</sup>) | O(n<sup>2</sup>) |
| 选择排序 | ✘          | ✔️          | O(n<sup>2</sup>) | O(n<sup>2</sup>) | O(n<sup>2</sup>) |

## 拓展

序度

- 有序度是数组中具有有序关系的元素对的个数。（有序元素对：a[i]<a[j]，如果i<j）
- 满有序度：完全有序的数组的有序度。个数为：n*(n-1)/2
- 逆序度和有序度相反。（逆序元素对：a[i]>a[j]，如果i<j）
- 逆序度=满序度-有序度



# 12 | 排序（下）：如何用快排思想在O(n)内查找第K大元素？

## 归并排序

### 什么是归并排序？

- 如果要排序一个数组，先把数组从中间分成前后两个部分，然后分别对前后两个部分进行排序，再将排好序的部分合并成一个数组。

### 归并排序实现：

- mergeSort(array,l,h)分解为mergeSort(array,l,m)，mergeSort(array,m+1,h)，merge(array,l,m,h);
- merge借助临时数组，保存合并后数组，然后进行赋值。
- 要考虑左数组到最后，或者右数组到最后的情况
- 拓展：借助哨兵，将最大值放在左右数组的后面，可以减少边界判断的问题

### 归并排序分析：

- 原地排序算法：否
- 稳定排序算法：是
- 最好时间复杂度、最坏时间复杂度、平均时间复杂度都是O(nlogn)（与有序度无关）
- 空间复杂度：O(1)，一次执行一次合并函数，只需要借助O(n)

#### 归并排序时间复杂度计算：

2个子数组的归并排序时间+1次合并两个子数组的时间

```
T(1) = C
T(n)=2T(n/2)+n
		=2*(2T(n/4)+n/2)+n
		=4*T(n/4)+2n
		=4*(2T(n/8)+n/4)+2n
		=8T(n/8)+3n
		=2^k*T(n/2^k)+k*n
```

n/2^k=1，即k=logn，T(n)=2^k*C+nlogn=Cn+nlogn，O(n)=nlogn



## 快速排序

### 什么是快速排序？

- 选择一个数字作为分区点pivot，遍历数组，将小于分区点的数字放在左边，将大于分区点的数字放在右边
- 根据分治、递归的思想，递归排序p到q-1和q+1和r之间的数据

```
递推公式
quick_sort(p…r)=quick_sort(p…q-1)+quick_sort(q+1…r)

终止条件 p>=r
```

```
伪代码
quick_sort(A, n) {

}

quick_sort_c(A, p, r) {
	if (p>=r) return

	q = partition(A, p, r)
	quick_sort_c(A, p, q-1)
	quick_sort_c(A, q+1, r)
}
```

### 快排排序实现：

- 原地排序，分为两个数组，一个比分区点小的，一个比分区点大的
- i记录当前分区点的位置，j记录当前循环的位置，如果当前比较的a[j]<分区点，需要交换，则采用交换插入的方式，交换a[j]和a[i]，i++
- 最后交换i和分区点的数据就可以了

### 快速排序分析：

- 原地排序算法：是
- 稳定排序算法：否
- 最好时间复杂度：O(n*logn)，分区合理，每次都分为均等大小的区间，就和归并排序一样
- 最坏时间复杂度：O(n<sup>2</sup>)，分区极度导向一边，可能排好序的
- 平均时间复杂度：O(n*logn)，后面用递推树的知识解答

### 总结：

- 归并排序和快速排序，同样用到分治的思想
- 归并的处理过程是由下往上，先处理子问题，再合并
- 快速排序相反，是由上往下，先分区，再处理子问题

## 开篇问题

### 寻找第K大元素

- 选择分区点，第一次分区得到分区点p
- 如果p+1=K，则找到了。如果p+1<K，则数字在p+1到r的区间内；如果p+1>K，则数字在0到p-1区间内。依次循环往下找。
- 时间复杂度：O(n)
- n+n/2+n/4+……+1=2n-1（等比数列，乘以等比系数，再相减）



## 拓展：

### 分之思想：

- 分而治之，将一个大问题分解成小的子问题来解决。子问题解决了，大问题自然解决了。
- 分治思想是一种解决问题的思想，递归是编程的一种技巧