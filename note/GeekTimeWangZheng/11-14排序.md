# 11|排序（上）：为什么插入排序比冒泡排序更受欢迎？

## 1、排序算法的执行效率（排序性能）

- 最好情况、最坏情况、平均情况时间复杂度。——需要考虑不能数据下的性能表现
- 时间复杂度的系数、常数、低阶——时间复杂度反应的是数据规模n很大的时候增长趋势，实际软件开发中，我们排序的数据可能10-1000这样规模很小的数据，所以对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来
- 比较次数和交换次数（或移动）次数——基于比较的排序算法，都会用到比较、交换操作

## 2、排序算法其他度量指标

- 空间复杂度：原地排序算法，特指控件复杂度为O(1)的排序算法。
- 排序算法的稳定性：如果待排序的序列中存在值相等的袁术，经过排序之后，相等元素之间原有的先后顺序不变。

## 冒泡排序

### 什么是冒泡排序？

- 冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求，如果不满足就让它们互换。
- 一次冒泡会让至少一个元素移动到它应该在的位置。

### 冒泡排序分析：

- 原地排序算法：是
- 稳定排序算法：是
- 最好情况时间复杂度O(n)，最坏时间复杂度O(n<sup>2</sup>)
- 平均时间复杂度：满序度为n\*(n-1)/2，假设平均逆序度为其一半n\*(n-1)/2/2，有一个逆序元素对，就需要一次交换，所以平均情况时间复杂度为O(n<sup>2</sup>)

## 插入排序

### 什么是插入排序？

- 将数组中的数据分为两个区间，已排序区间和未排序区间。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的位置进行插入，并保证已排序区间数据一直有序。
- 移动操作的次数等于逆序度

### 插入排序分析：

- 原地排序算法：是
- 稳定排序算法：是
- 最好时间复杂度：O(n)，最坏时间复杂度O(n<sup>2</sup>)
- 平均时间复杂度：O(n<sup>2</sup>)，插入一个数据的平均时间复杂度是O(n)，重复n次插入，所以为O(n<sup>2</sup>)

## 选择排序

### 什么是选择排序？

- 数据也分为已排序区间和未排序区间。每次从未排序区间中选择最小的元素，放在已排序区间的末尾。
- 每次都选择出最小元素，然后放在已排序区间的末尾，即交换这两个位置。

选择排序分析：

- 原地排序算法：是
- 稳定排序算法：否
- 最好时间复杂度：O(n<sup>2</sup>)，最坏时间复杂度O(n<sup>2</sup>)
- 平均时间复杂度：O(n<sup>2</sup>)

## 开篇问题：

### 插入排序比冒泡排序优

- 冒泡排序不管怎么优化，交换次数都是逆序度
- 插入排序不管怎么优化，元素移动次数都是逆序度
- 但是代码实现，冒泡排序比插入排序实现复杂，冒泡排序需要3次赋值操作，插入排序只需要一个
- 插入排序还可以优化

## 总结：

|          | 是否稳定？ | 原地排序？ | 最好             | 最坏             | 平均             |
| -------- | ---------- | ---------- | ---------------- | ---------------- | ---------------- |
| 冒泡排序 | ✔️          | ✔️          | O(1)             | O(n<sup>2</sup>) | O(n<sup>2</sup>) |
| 插入排序 | ✔️          | ✔️          | O(1)             | O(n<sup>2</sup>) | O(n<sup>2</sup>) |
| 选择排序 | ✘          | ✔️          | O(n<sup>2</sup>) | O(n<sup>2</sup>) | O(n<sup>2</sup>) |

## 拓展

序度

- 有序度是数组中具有有序关系的元素对的个数。（有序元素对：a[i]<a[j]，如果i<j）
- 满有序度：完全有序的数组的有序度。个数为：n*(n-1)/2
- 逆序度和有序度相反。（逆序元素对：a[i]>a[j]，如果i<j）
- 逆序度=满序度-有序度