# 11|排序（上）：为什么插入排序比冒泡排序更受欢迎？

## 1、排序算法的执行效率（排序性能）

- 最好情况、最坏情况、平均情况时间复杂度。——需要考虑不能数据下的性能表现
- 时间复杂度的系数、常数、低阶——时间复杂度反应的是数据规模n很大的时候增长趋势，实际软件开发中，我们排序的数据可能10-1000这样规模很小的数据，所以对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来
- 比较次数和交换次数（或移动）次数——基于比较的排序算法，都会用到比较、交换操作

## 2、排序算法其他度量指标

- 空间复杂度：原地排序算法，特指控件复杂度为O(1)的排序算法。
- 排序算法的稳定性：如果待排序的序列中存在值相等的袁术，经过排序之后，相等元素之间原有的先后顺序不变。

## 冒泡排序

### 什么是冒泡排序？

- 冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求，如果不满足就让它们互换。
- 一次冒泡会让至少一个元素移动到它应该在的位置。

### 冒泡排序分析：

- 原地排序算法：是
- 稳定排序算法：是
- 最好情况时间复杂度O(n)，最坏时间复杂度O(n<sup>2</sup>)
- 平均时间复杂度：满序度为n\*(n-1)/2，假设平均逆序度为其一半n\*(n-1)/2/2，有一个逆序元素对，就需要一次交换，所以平均情况时间复杂度为O(n<sup>2</sup>)

## 插入排序

### 什么是插入排序？

- 将数组中的数据分为两个区间，已排序区间和未排序区间。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的位置进行插入，并保证已排序区间数据一直有序。
- 移动操作的次数等于逆序度

### 插入排序分析：

- 原地排序算法：是
- 稳定排序算法：是
- 最好时间复杂度：O(n)，最坏时间复杂度O(n<sup>2</sup>)
- 平均时间复杂度：O(n<sup>2</sup>)，插入一个数据的平均时间复杂度是O(n)，重复n次插入，所以为O(n<sup>2</sup>)

## 选择排序

### 什么是选择排序？

- 数据也分为已排序区间和未排序区间。每次从未排序区间中选择最小的元素，放在已排序区间的末尾。
- 每次都选择出最小元素，然后放在已排序区间的末尾，即交换这两个位置。

选择排序分析：

- 原地排序算法：是
- 稳定排序算法：否
- 最好时间复杂度：O(n<sup>2</sup>)，最坏时间复杂度O(n<sup>2</sup>)
- 平均时间复杂度：O(n<sup>2</sup>)

## 开篇问题：

### 插入排序比冒泡排序优

- 冒泡排序不管怎么优化，交换次数都是逆序度
- 插入排序不管怎么优化，元素移动次数都是逆序度
- 但是代码实现，冒泡排序比插入排序实现复杂，冒泡排序需要3次赋值操作，插入排序只需要一个
- 插入排序还可以优化

## 总结：

|          | 是否稳定？ | 原地排序？ | 最好             | 最坏             | 平均             |
| -------- | ---------- | ---------- | ---------------- | ---------------- | ---------------- |
| 冒泡排序 | ✔️          | ✔️          | O(1)             | O(n<sup>2</sup>) | O(n<sup>2</sup>) |
| 插入排序 | ✔️          | ✔️          | O(1)             | O(n<sup>2</sup>) | O(n<sup>2</sup>) |
| 选择排序 | ✘          | ✔️          | O(n<sup>2</sup>) | O(n<sup>2</sup>) | O(n<sup>2</sup>) |

## 拓展

序度

- 有序度是数组中具有有序关系的元素对的个数。（有序元素对：a[i]<a[j]，如果i<j）
- 满有序度：完全有序的数组的有序度。个数为：n*(n-1)/2
- 逆序度和有序度相反。（逆序元素对：a[i]>a[j]，如果i<j）
- 逆序度=满序度-有序度



# 12 | 排序（下）：如何用快排思想在O(n)内查找第K大元素？

## 归并排序

### 什么是归并排序？

- 如果要排序一个数组，先把数组从中间分成前后两个部分，然后分别对前后两个部分进行排序，再将排好序的部分合并成一个数组。

### 归并排序实现：

- mergeSort(array,l,h)分解为mergeSort(array,l,m)，mergeSort(array,m+1,h)，merge(array,l,m,h);
- merge借助临时数组，保存合并后数组，然后进行赋值。
- 要考虑左数组到最后，或者右数组到最后的情况
- 拓展：借助哨兵，将最大值放在左右数组的后面，可以减少边界判断的问题

### 归并排序分析：

- 原地排序算法：否
- 稳定排序算法：是
- 最好时间复杂度、最坏时间复杂度、平均时间复杂度都是O(nlogn)（与有序度无关）
- 空间复杂度：O(1)，一次执行一次合并函数，只需要借助O(n)

#### 归并排序时间复杂度计算：

2个子数组的归并排序时间+1次合并两个子数组的时间

```
T(1) = C
T(n)=2T(n/2)+n
		=2*(2T(n/4)+n/2)+n
		=4*T(n/4)+2n
		=4*(2T(n/8)+n/4)+2n
		=8T(n/8)+3n
		=2^k*T(n/2^k)+k*n
```

n/2^k=1，即k=logn，T(n)=2^k*C+nlogn=Cn+nlogn，O(n)=nlogn



## 快速排序

### 什么是快速排序？

- 选择一个数字作为分区点pivot，遍历数组，将小于分区点的数字放在左边，将大于分区点的数字放在右边
- 根据分治、递归的思想，递归排序p到q-1和q+1和r之间的数据

```
递推公式
quick_sort(p…r)=quick_sort(p…q-1)+quick_sort(q+1…r)

终止条件 p>=r
```

```
伪代码
quick_sort(A, n) {

}

quick_sort_c(A, p, r) {
	if (p>=r) return

	q = partition(A, p, r)
	quick_sort_c(A, p, q-1)
	quick_sort_c(A, q+1, r)
}
```

### 快排排序实现：

- 原地排序，分为两个数组，一个比分区点小的，一个比分区点大的
- i记录当前分区点的位置，j记录当前循环的位置，如果当前比较的a[j]<分区点，需要交换，则采用交换插入的方式，交换a[j]和a[i]，i++
- 最后交换i和分区点的数据就可以了

### 快速排序分析：

- 原地排序算法：是
- 稳定排序算法：否
- 最好时间复杂度：O(n*logn)，分区合理，每次都分为均等大小的区间，就和归并排序一样
- 最坏时间复杂度：O(n<sup>2</sup>)，分区极度导向一边，可能排好序的
- 平均时间复杂度：O(n*logn)，后面用递推树的知识解答

### 总结：

- 归并排序和快速排序，同样用到分治的思想
- 归并的处理过程是由下往上，先处理子问题，再合并
- 快速排序相反，是由上往下，先分区，再处理子问题

## 开篇问题

### 寻找第K大元素

- 选择分区点，第一次分区得到分区点p
- 如果p+1=K，则找到了。如果p+1<K，则数字在p+1到r的区间内；如果p+1>K，则数字在0到p-1区间内。依次循环往下找。
- 时间复杂度：O(n)
- n+n/2+n/4+……+1=2n-1（等比数列，乘以等比系数，再相减）

## 课后思考：

10个300M的文件，如何合并形成新的文件，内存大小1G?

### 我的解决思路：

- 10个小数组，然后去取10次比较大小，然后取最小的写入文件，然后比较已写入的位置
- 如果当前最小的数据组已经完全写入了，需要读取新的数据进入数组，如果没有则不操作，也不参与比较
- 知道所有的数组都写入了，没有数据了

### 其他思路：

- 先拆分小文件，小文件最小值排序，前几个小文件进行归并排序即可



## 拓展：

### 分之思想：

- 分而治之，将一个大问题分解成小的子问题来解决。子问题解决了，大问题自然解决了。
- 分治思想是一种解决问题的思想，递归是编程的一种技巧



# 13|线性排序：如何根据年龄给100万用户数据排序？

## 线性排序

- 时间复杂度为O(n)的排序算法
- 包含桶排序、计数排序、基数排序
- 是基于非比较的排序算法

## 桶排序

### 什么是桶排序？

- 核心思想是将将要排序的数据分到几个有序的桶里，每个桶里的数据再单独排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的。
- 时间复杂度：O(m\*k\*logk)=O(m\*n/m\*log(n/m))=O(n*log(n/m))  (m个桶，k=n/m)

### 排序数据要求和场景

- 排序的数据很容易划分到m个桶中，并且桶天然是有序的
- 数据在各个桶之间的分布是均匀的
- 场景：桶比较适合用在外部排序中。

## 计数排序

### 什么是计数排序？

- 桶排序的一种特殊情况
- k桶的范围不大，桶内的数据都是相同的，省去桶内排序的时间

### 计数排序的实现

A[8]表示原数组，C[6]表示桶计数的数组，R[8]表示排序后的数组

核心思想：快速计算出数据在排序后的数组中的位置

- 先遍历A原数组，计算每个桶的总数的个数，并放入C[6]中
- 然后遍历C[6]，累加前面的数字，就能得到从前面到现在这个值的总数，这样能确定每个桶的数字的在R数组中的最大位置
- 然后从后遍历A数组，然后依次去C[k]，对应的位置放入进去，然后C[k]-1,这样能保证是稳定排序的

### 计数排序场景:

- 计数排序只能用在数据范围不大的场景（如果数据范围k比n大很多就不适合了）
- 计数排序只能给非负整数排序（如果不满足要求，可以在不改变相对大小的情况下，转换成非负整数，比如负数+1000等）

## 基数排序

### 什么是基数排序？

- 将数据分割成每一位，每一位从后往前通过稳定的排序算法来进行排序
- 一定要是稳定的排序算法，否则低位的排序就没有意义了

### 基数排序的场景：

- 数据可以切分出独立的位（位数不够可以补齐）
- 位之间的数据有递进的关系
- 每一位的数据范围都不大，要可以用线性排序的算法来排序，否则基数排序也做不到O(n)

## 开篇问题

100万考生年龄排序

- 使用桶排序，划分1-120个桶，遍历放在桶内

## 课后思考

字母排序

- 方法一：桶排序，划分小写字母、数字、大写字母3个桶，然后遍历入桶，然后遍历桶串起来
- 方法二：指针a、b，a指向小写字母，b指向大写字母，如果a遇到大写字母就停止，b遇到小写字母就停止，然后a、b进行交换。如果是包含数字，先分成小写字母和非小写字母的区间，非小写字母区间在用同样的方式区分数字和大写字母。



# 14|排序优化：如何实现一个通用的、高性能的排序函数？

## 排序算法总结

|          | 时间复杂度         | 是稳定排序 | 是原地排序 |
| -------- | ------------------ | ---------- | ---------- |
| 冒泡排序 | O(n<sup>2</sup>)   | 是         | 是         |
| 插入排序 | O(n<sup>2</sup>)   | 是         | 是         |
| 选择排序 | O(n<sup>2</sup>)   | 否         | 是         |
| 归并排序 | O(n*logn)          | 是         | 否         |
| 快速排序 | O(n*logn)          | 否         | 是         |
| 桶排序   | O(n)               | 是         | 否         |
| 计数排序 | O(n+k) k是数据范围 | 是         | 否         |
| 基数排序 | O(dn) d是维度      | 是         | 否         |

## 快排和归并比较

- 归并无论什么情况的时间复杂度都是O(n*logn)，但是不是原地排序算法，空间复杂度O(n)
- 快排一般是O(n*logn)，最坏情况为O(n<sup>2</sup>)，但是可以优化避免

## 快排优化

- 核心点：分区点的选择，保证分区两边差不多
- 1、三位取中法——首、尾、中间，分别取一个数然后比大小
- 2、随机法——每次都随机，每次都最差的概率很低

### Glib排序函数qsort分析

- 小数据量使用归并排序
- 大数据量使用快速排序
- 小规模的时候，O(n<sup>2</sup>)的时间并不比O(nlogn)的时间长

## Java排序的分析

### 自己的分析：



### 别人的结论一

java1.8中的排序，在元素小于47的时候用插入排序，大于47小于286用双轴快排，大于286用timsort归并排序，并在timesort中记录数据的连续的有序段的的位置，若有序段太多，也就是说数据近乎乱序，则用双轴快排，当然快排的递归调用的过程中，若排序的子数组数据数量小，用插入排序。

### 别人的结论二

查看了下Arrays.sort的源码，主要采用TimSort算法, 大致思路是这样的：

1 元素个数 < 32, 采用二分查找插入排序(Binary Sort)
2 元素个数 >= 32, 采用归并排序，归并的核心是分区(Run)
3 找连续升或降的序列作为分区，分区最终被调整为升序后压入栈
4 如果分区长度太小，通过二分插入排序扩充分区长度到分区最小阙值
5 每次压入栈，都要检查栈内已存在的分区是否满足合并条件，满足则进行合并
6 最终栈内的分区被全部合并，得到一个排序好的数组

Timsort的合并算法非常巧妙：

1 找出左分区最后一个元素(最大)及在右分区的位置
2 找出右分区第一个元素(最小)及在左分区的位置
3 仅对这两个位置之间的元素进行合并，之外的元素本身就是有序的



## 拓展

### Java里面的排序函数：

- Collections.sort()
- Arrays.sort