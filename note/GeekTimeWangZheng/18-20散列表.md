# 18 | 散列表（上）：Word文档中的单词拼写检查功能是如何实现的？

## 什么是散列表？

- 散列表用的是数组支持随机访问的的特性，散列表是数组的拓展
- 利用散列函数计算散列值作为数组下标
- 核心概念：键或关键字、散列函数、散列值（hash值或哈希值）
- 散列函数，是一个函数，定义为hash(key)，将键计算成散列值的函数

## 散列函数

- 散列函数计算得到的散列值是一个非负整数
- 如果key1 = key2，那hash(key1) =  hash(key2)
- 如果key1 ≠ key2，那hash(key1) ≠ hash(key2)

## 散列冲突

要找一个不同的key对应的散列值都不一样的散列函数，几乎不可能。

### 1、开放寻址法

#### 线性探测

- 插入操作：如果存储位置不为空，向后探测，放入为空的位置
- 删除操作：查找到对应位置，标记为deleted
- 查找操作：查找存储位置，如果不是，则向后探测跳过deleted的数据，发现了就存在，知道发现空的位置，则失败

#### 二次探测

- 线性探测步长为1，二次探测为hash(key) + 0, hash(key) + 1<sup>2</sup> + hash(key) + 2<sup>2</sup> + ...

#### 双重散列

- 不知使用一个散列函数，而是一组散列函数hash1(key)、hash2(key)、hash3(key)
- 一个没找到用下一个散列函数

#### 总结

- 散列表的装载因子 = 填入表中的元素的个数 / 散列表的长度
- 空闲位置少的时候，无论哪种开放寻址法，都无法避免散列冲突
- 装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降

### 2、链表法

- 每个桶或槽对应的是一个链表
- 所有散列值相同的元素都放在对应槽的链表里
- 时间复杂度：O(k)=O(n/m)，如果平均分配，m为桶的个数

## 开篇思考题

Word里面字母检查功能？

- 学会预估：20万个单词，平均单词长度10，1个单词长度为10字节，20万单词为2M，放大10被也才20M，可以放在内存中
- 散列表存储数据，可以很快的查找是否存在

## 课后思考

### 1、假设我们有10万条URL访问日志，如何按照访问次数给URL排序？

- 构建散列表，key为URL，value为访问的次数，记录最大的次数K
- 然后根据访问次数再排序，如果K比较小使用桶排序O(k)，如果K比较大（大于10万），使用快排为O(nlogn)

### 2、有两个字符串数组，每组大约有10万条字符串，如何快速找出两个数组相同的字符串？

- 以第一个数组构建散列表，然后第二个数组依次去查找



# 19 | 散列表（中）：如何打造一个工业级水平的散列表？

## 关键技术：

1. 散列函数的设计：散列函数不能太复杂（影响计算），散列随机且均匀分布
2. 装载因子过大的处理：过大超过阈值进行扩容
3. 避免低效扩容：一次扩容耗时过多，将扩容操作穿插在插入操作中
4. 冲突解决办法：开放寻址法和链表法



## 散列冲突解决办法：

### 开放寻址法：

- 优点：1、有效利用CPU缓存技术加快查询速度；2、序列化简单

- 缺点：1、删除数据比较麻烦；2、冲突代价更高
- 场景：数据量小、装载因子小的时候，适合使用开放寻址法。这要是ThreadLocalMap使用开放寻址法的解决散列冲突的原因

### 链表法：

- 优点：1、内存利用率高，不需要提前申请；2、对大装载因子容忍度更大；
- 缺点：1、存储指针，额外消耗内存；2、CPU缓存不友好
- 场景：比较适合存储大对象、大数据量的散列表；更加灵活，可以使用红黑树代替链表



## Java中HashMap这种工业级散列表

1. 初始大小：16
2. 装载因子和动态扩容：最大装载因子0.75
3. 散列冲突解决办法：链表法，链表长度太长超过8，转换成红黑树；节点小于8个，使用链表
4. 散列函数：(h ^ (h >>> 16)) & (capitity -1)



## 如何实现工业级散列表？

- 设计合适的散列函数
- 定义装载因子阈值，并且设计动态扩容策略
- 选择合适的散列冲突解决办法