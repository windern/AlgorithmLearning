# 15 | 二分查找（上）：如何用最省内存的方式实现快速查找功能？

## 什么是二分查找？

- 折半查找
- 二分思想，每次都与中间的数据比较，将待查找区间缩小为之前的一半，直到找到要查找的元素，或者减少为0

## 时间复杂度分析

- 时间复杂度为logn
- 空间的大小变化，n、n/2、n/4……n/2^k=1，即k次查找，k=logn
- 对数的恐怖，2^32次方是42亿，也只需要32次
- 指数同样恐怖

## 二分查找的实现

3处需要注意的点

- 循环退出条件，while(low<=high)
- mid的取值，mid=low+(high-low)/2
- low和high的更新，low=mid-1，high=mid+1，这样避免死循环

## 二分查找的场景

- 二分查找依赖顺序表结构，即数组（需要下标的随机访问）
- 二分查找针对有序数据（一次排序多次查找，动态集合需要维护有序不适合）
- 适合静态数据
- 数据量太小不适合二分查找（太小二分查找和遍历差不多，数据比较耗时时无论大小多少都推荐二分查找）
- 数据量太大也不适合二分查找（需要连续的内存空间）

## 开篇问题

1000万数据判断是否存在

- 二分查找最适合，大小刚好合适

## 课后思考

### 如何求一个数的平方根？要求精确到小数点后6位。

- 二分查找思想，一次取中间值
- 退出条件：(mid+0.000001)\*(mid+0.000001)>x && (mid-0.000001)\*(mid-0.000001)<x
- 然后mid替换成low和high

### 链表实现二分查找时间复杂度分析？

#### 如果是双向链表

- N = n/2 + n/4 +n/8 + ... + 1 
- N/2 =       n/4 + n/8 + ...+ 1 + 1/2
- N/2 = n/2 -1/2
- N=n-1
- 时间复杂度为O(n)



# 16 | 二分查找（下）：如何快速定位IP对应的省份地址？

## 二分查找变形问题（包含重复元素的）

- 查找第一个元素等于给定值的元素
- 查找最后一个元素等于给定值的元素
- 查找第一个大于等于给定值的元素
- 查找最后一个小于等于给定值的元素

## 变体一：查找第一个等于给定值的元素

- 如果查找到给定值，判定如果到头或者前面一个元素不等于给定值，则返回；如果相等则，high=mid-1，同理继续往前找

## 变体二：查找最后一个等于给定值的元素

- 如果查找到给定值，判定如果到尾或者后面一个元素不等于给定值，则返回；如果相等，low = mid+1，同理继续往后找

### 变体三：查找第一个大于等于给定值的元素

- 如果值大于等于给定值，如果到0了，或者前面值小于给定值了，说明这就是结果；如果值小于给定值，low = mid + 1

### 变体四：查找最后一个小于等于给定值的元素

- 如果值小于等于给定值，如果到数组最后面或者后面的值大于给定值了，说明就是结果；如果值大于给定值了，high = mid - 1

## 二分查找注意点

- 二分查找能解决的，给定值查找推荐使用散列表和二叉查找树
- 二分查找更适合解决变体的近似问题，变体问题散列表、二叉树比较难实现
- 二分查找的注意点：终止条件（low<=high）、区间上下界更新方法（更新low还是high）、返回值选择（何时返回值mid）

## 开篇问题

快速定位ip地址的归属？

- ip转换成32位整数
- 转换为变体四，查找最后一个小于等于给定值的元素

## 课后思考

### 二分查找循环有序数组的最小值？（即起始点）

- 二分查找算法的核心点：条件退出的位置
- 变化点的特点：变化点的左侧 大于 第一个点，变化点的右侧 小于第一个点
- 找到中间mid
- 退出条件，如果a[mid] > a[mid + 1] || a[mid-1] < a[mid]
- 如果a[mid] > a[0]，在mid的右边搜索变化点，low = mid + 1（注意不是a[mid]和a[low]比较）
- 如果a[mid] < a[0]，在mid的左边搜索变化点，high = mid -1

### 如何使用二分查找，搜索循环的有序数组，例如4，5，6，1，2，3？(leetcode的33题)

解法一：（自己想的）

- 先通过一次二分查找，查找循环数组的起始节点k
- 然后给定值，数组头、起始节点k比较，可以理解为两个有序的数组了

解法二：

我们发现循环数组存在一个性质：以数组中间点为分区，会将数组分成一个有序数组和一个循环有序数组。

- 如果首元素小于 mid，说明前半部分是有序的，后半部分是循环有序数组；
- 如果首元素大于 mid，说明后半部分是有序的，前半部分是循环有序的数组；
- 如果目标元素在有序数组范围中，使用二分查找；
- 如果目标元素在循环有序数组中，设定数组边界后，使用以上方法继续查找。（递归实现）



# 17 | 跳表：为什么Redis一定要用跳表来实现有序集合？

## 什么是跳表？

- 链表加多级索引的数据结构就是索引
- 每m个节点抽取一个节点到上一层，抽取出来的那级叫做索引或者索引层
- 加了一层索引后，查找一个节点需要遍历的节点个数减少了，也就是查找效率提高了

## 复杂度分析

### 时间复杂度分析

- 第一级索引个数n/2，第二级索引个数n/4，第k级索引个数n/2^k，第k级索引的个数是第k-1级索引的一半
- 跳表的高度：最后一级节点进包含两个元素，第h级节点个数为2，所以n/2^h=2，2^(h+1)=n，h=logn-1
- 每一级索引查询的次数为m = 3，考虑通用k级的情况，假设k级找到x在z之间，则k-1级x-z之间只多了一个y节点，也就是在遍历x、y、z三个节点就够了
- 所以整体时间复杂度为O(m\*h)=O(3\*logn)=O(logn)

### 空间复杂度分析

- S =n/2 +n/4 + n/2^k +2
- S/2 =     n/4 +... + 2 + 1
- S-S/2 = n/2-1
- S = n-2
- 空间复杂度O(n)
- 如果每3个节点抽取一个节点，空间为n/2
- 实际开发中并不需要太关心额外存储空间，因为原始链表中可能存储的是很大的对象，对象比索引节点大很多

## 其他操作

### 动态插入

- 插入先寻找到插入点O(logn)
- 通过随机函数，生成值K，第1级至第k级插入索引
- 随机函数很讲究，从概率角度讲，影响跳表的索引值的大小和数据大小的平衡性

### 动态删除

- 如果删除值在索引中，既要删除原链表节点，也要删除索引节点
- 如果是单链表，需要找到前驱节点

## 开篇问题

Redis中使用跳表实现有序集合的存储？

- Redis支持的操作：插入、删除、查找一个数据、按区间查找、输出有序序列，按区间查找红黑树的效率没有跳表高
- 跳表比红黑树容易实现，代码简单，好懂好写，即可读性好，不易出错
- 跳表更灵活，通过改变构建索引的策略，有效平衡执行效率和内存消耗

## 课后思考

如果每3个节点或5个节点抽取一个节点，时间复杂度是多少？

- 第一级索引个数n/m，第二级索引个数n/m^2，第k级索引个数n/m^k .... 第h级索引个数n/m^h = 1
- h = log<sub>m</sub>n
- 每一级查找的个数 m+1
- 所以时间复杂度为O((m+1)*h)=O((m+1)\*log<sub>m</sub>n)=O(n)

## 拓展

- 跳表比红黑树出现的时间晚
- 很多语言的Map是使用红黑树实现的，可以使用现成的
- 跳表需要自己实现