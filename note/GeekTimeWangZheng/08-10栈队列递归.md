# 08|栈：如何实现浏览器的前进和后退功能？

## 什么是栈

- 后进者先出，先进者后出。
- 栈是一种“操作受限”的线性表，只允许一段插入和删除数据。
- 数组和链表可以替代栈，但是暴露了太多的接口，容易不可控。
- 当某个数据集合只涉及在一段插入和删除数据，并且满足后进先出、先进后出的特性，我们就应该首选“栈”这种数据结构。
- 操作函数：push()、pop()、peek()

## 如何实现栈

- 用数组实现的栈，我们叫做顺序栈。用链表实现的栈，我们叫做链式栈。
- 入栈、出栈的时间复杂度都是O(1)
- 动态扩容的顺序栈：入栈、出栈的时间复杂度也是O(1)（通过摊还分析法分析得到）

## 栈的应用：

- 函数调用栈：函数栈帧，通过栈来保存临时变量
- 表达式求值：两个栈实现，一个操作数的栈，一个运算符的栈。如果遇到数直接入栈。如果遇到运算符，和栈顶元素比较，如果比栈顶运算符的优先级高，则符号入栈；如果比栈顶运算符的优先级相同或者低，就拿出两个数进行运算；然后继续比较。
- 括号匹配：左括号入栈，右括号出栈，最后看栈是否为空
- 浏览器的前进和后退：两个栈实现，一个栈保存浏览记录，一个栈保存后退的记录，如果跳转新的后退记录的栈清空。

## 课后思考：

### 1、为什么函数调用要用“栈”来保存临时变量？其他数据结构不行吗？

- 并不是一定要用栈来保存临时变量，只不过函数调用符合后进先出的特性，用栈来实现顺理成章。
- 从调用函数进入被调用函数，对于数据来说，变化的是作用域。在进入被调用函数的时候，分配一段栈空间给这个函数的变量，在函数结束的时候，将栈顶复位，正好回到调用函数的作用域内。

### 2、JVM内存管理中有个“堆栈”的概念？

- 内存中的堆栈和数据结构堆栈不是一个概念，可以说内存中的堆栈是真实存在的物理区，数据结构中的堆栈是抽象的数据存储结构。
- 内存空间在逻辑上分为三部分：代码区、静态数据区和动态数据区，动态数据区有分为栈区和堆区。
- 代码区：存储方法体的二进制代码。高级调度（作业调度）、中级调度（内存调度）、低级调度（进程调度）控制代码区执行代码的切换。
- 静态区：存储全局变量、静态变量、常量，常量包含final修饰的常量和String常量。系统自动分配和回收。
- 栈区：存储运行方法的形参、局部变量、返回值。由系统自动分配和回收。
- 堆区：new一个对象的引用或地址存储在栈区，指向该对象存储在堆区中的真实数据。



# 09|队列：队列在线城池等有限资源池中的应用

## 什么是队列

- 先进者先出，这就是典型的队列
- 基本操作：入队enqueue()，放一个数据在队尾；出队dequeue()，从队列头部去一个元素。
- 队列和栈一样，也是一种操作受限的线性表数据结构。
- 额外特性的队列：循环队列、阻塞队列、并列队列。

## 实现队列：

- 用数组实现的队列叫做顺序队列，用链表实现的队列叫做链式队列。
- 队列维护两个指针：一个是head指针，指向队头；一个是tail指针，指向队尾。
- 数组实现队列的时候，当入队不够时，才实现一次数据搬移，解决频繁搬移数据的问题。

## 循环队列：

- 首尾相连形成一个环。
- 用数组实现队列的时候，如果使用循环顺序队列，可以解决数据搬移的问题。
- 队空的情况：head==tail
- 队满的情况：(tail+1)%n=head
- 循环队列会浪费一个数组的存储空间，因为队列满的时候tail指向的位置实际上没有存储数据。
- (i+1)%n可以防止越界，同时重新开始计算。

## 阻塞队列：

- 阻塞队列其实就是在队列的基础上增加了阻塞操作。
- 在队列为空的时候，从队头取数据就会被阻塞。因此此时还没有数据可取，直到队列中有了数据才能返回。
- 如果队列已经满了，那么插入数据的操作就会被阻塞，知道队列中有空闲位置后再插入数据，然后再返回。
- 可以使用阻塞队列，轻松实现一个“生产者-消费者模型”。

## 并发队列：

- 线程安全的队列我们叫做并发队列。
- 最简单直接的方式是在enqueue()、dequeue()方法上加锁。
- 基于数组的循环队列，利用CAS原子操作，可以实现比较高效的并发队列。这也是循环队列比链式队列应用更广泛的原因。

## 线城池的处理：

- 线城池没有空闲线程时，处理策略：第一种是非阻塞的处理方式，直接拒绝任务请求；另一种是阻塞的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理。
- 基于链表的实现方式，可以实现一个支持无线排队的无限队列（unbounded queue）。针对响应事件比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。
- 基于数组的实现的有界队列（bounded queue），队列的大小有限，超过队列大小时，请求会被拒绝，这种对响应时间敏感的系统来说，就相对更加合理。
- 对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。

## 课后思考：

### 1、除了线程池这种池结构会用到队列排队请求，你还知道有哪些类似的池结构或者场景中会用到队列的排队请求呢？

- 分布式应用中的消息队列

### 2、今天讲到并发队列，如何实现无锁并发队列？

- 考虑使用CAS实现无锁队列。在入队前，获取tail位置，入队时比较tail是否发生变化，如果否，允许入队，反之，本次入队失败。出队则是获取head位置，进行CAS。

## 拓展：

### 队列的系统使用：

- 高性能队列Disruptor、Linux环形队列，都用到了循环并发队列
- Java concurrent并发包利用ArrayBlockingQueue来实现公平锁

### Java中的几种阻塞队列

相关链接：https://blog.csdn.net/gaotiedun1/article/details/86606135

- ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。
- LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。
- PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。
- DelayQueue：一个使用优先级队列实现的无界阻塞队列。
- SynchronousQueue：一个不存储元素的阻塞队列。
- LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。
- LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列

### 实现Java 阻塞队列

相关链接：https://segmentfault.com/a/1190000020005820

### Java的Queue的接口使用：

#### offer，add 区别：

一些队列有大小限制，因此如果想在一个满的队列中加入一个新项，多出的项就会被拒绝。

这时新的 offer 方法就可以起作用了。它不是对调用 add() 方法抛出一个 unchecked 异常，而只是得到由 offer() 返回的 false。

#### poll，remove 区别：

remove() 和 poll() 方法都是从队列中删除第一个元素。remove() 的行为与 Collection 接口的版本相似， 但是新的 poll() 方法在用空集合调用时不是抛出异常，只是返回 null。因此新的方法更适合容易出现异常条件的情况。

#### peek，element区别：

element() 和 peek() 用于在队列的头部查询元素。与 remove() 方法类似，在队列为空时， element() 抛出一个异常，而 peek() 返回 null。



# 10|递归：如何用三行代码找到“最终推荐人”？

## 什么是递归？

- 方法或函数调用自身方式称为递归调用，调用称为递，返回称为归。

## 使用递归解决问题的三个条件：

- 一个问题的解可以分解为几个子问题的解
- 这个问题的解与分解之后的子问题，除了数据规模不同，求解思路完全一样
- 存在递归终止条件

## 如何编写递归代码？

- 写出递归公式，找到终止条件。
- 写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公司，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。
- 编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用一层层的调用关系，不要试图用人脑去分解递归的每个步骤。

## 递归代码注意的问题点：

- 递归代码要警惕堆栈溢出：每调用一个函数，都会将临时变量封装成栈帧压入内存栈，等函数执行完时才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。——解决办法：在代码中限制递归调用的最大深度来解决问题。（并不能完全解决问题，因为允许的递归深度和当前线程的栈空间有关系，事先无法计算）
- 递归代码要警惕重复计算：多次用到同一个值。——解决办法：通过一个数据结构（比如散列表）来表村已经求解过f(k)
- 函数调用耗时多
- 空间复杂度高

## 递归改循环

- 所有递归代码都可以改为迭代循环的非递归代码
- 因为递归本身就是借助栈来实现，只不过我们使用的栈是系统或者虚拟机本身提供的
- 如果我们自己在内存对上实现栈，手动模拟入栈和出栈过程，这样任何递归代码都可以改成看上去不是递归代码的样子

## 课后思考：

### IDE单步调试递归：

- 打印日志发现，递归值
- 结合条件断点进行调试

## 拓展：

### 尾递归：（后面来再看一遍）

- 尾递归函数是递归函数的一种，其中递归调用是递归函数中的最后一条指令。并且在函数中应该只有一次递归调用。——即直接return返回递归调用函数的值。
- 尾递归的好处是，它可以避免递归调用期间栈空间开销的累积，因为系统可以为每个递归调用重用栈中的固定空间。——但是需要编译器实现才行
- 并不是所有的编程语言都支持这种优化，比如 C，C++ 支持尾递归函数的优化。另一方面，Java 和 Python 不支持尾递归优化。
- 别人实现的用lamda懒加载（惰性求值）实现的尾递归优化，链接：https://www.jb51.net/article/126839.htm



