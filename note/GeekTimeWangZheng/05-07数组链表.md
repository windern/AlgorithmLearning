# 05|数组：为什么很多编程语言中数组都从0开始编号？

    ## 什么是数组？

    - 数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。
    - 线性表
    - 连续的内存空间和相同类型的数据。

    ### 线性表和非线性表

- 线性表：数据排成像一条线一样的结构。每个线性表上的数据只有前和后的两个方向。数组、链表、队列、栈等是线性表结构。
- 非线性表：数据之间并不是简单的前后关系。二叉树、堆、图等等是非线性表。

## 如何使用数组

### 支持随机访问：

- 数组支持随机访问，根据下标随机访问的时间复杂度为O(1)
- 而不是查找的时间复杂度为O(1)，用排好序的数组使用二分查找的查找的时间复杂度为O(logn)

### 插入：

- 搬运插入：平均时间复杂度O(n)，(1+2+3+...+n)/n = O(n)
- 交换插入：时间复杂度O(1)，k位放在最后，k位放需要插入的数据

### 删除：

- 搬运删除：平均时间复杂度O(n)
- 标记删除：先标记删除的位置，当位置不够需要删除的时候执行真正的删除操作，减少了相应的时间。（比如JVM标记清除垃圾回收算法的核心思想）

### 数组越界

- 需要警惕数组越界

## 容器：

- ArrayList最大的优势就是可以将很多数组操作的细节封装起来。比如数组插入、删除数据是需要搬移其他数据等。
- ArrayList支持动态扩容。（但是如果事先能确定需要存储的数据大小，最好在创建ArrayList的时候事先指定大小）

## 数组比较适合的场景：

- 希望使用基本数据类型。（ArrayList无法存储基本类型，Autoboxing、Unboxing则有一定的性能消耗）
- 如果数据大小事先已知，并且对数据的操作非常简单，用不到ArrayList提供的大部分方法，也可以直接使用数组。
- 表示多维数组时，用数组往往会更加直观。
- 一般业务开发，直接使用容器就足够了，省时省力。

## 为什么数组都从0开始编号？

- “下标”最确切的定义应该是“偏移”。
- a[k]_address = base_address + k * type_size
- 如果从1开始计数，变成a[k]_address = base_address + (k-1) * type_size
- 对于CPU多了一次减法指令，数组作为非常基础的数据结构，通过下标随机访问数组元素有事其非常基础的编程操作，效率的优化就要尽可能做到极致。



## 课后思考：

### JVM标记清除算法

- 大多数主流虚拟机采用可达性分析算法来判断对象是否存活
- 标记清除算法不足：1、效率问题。标记和清理效率都不是很高。2、空间问题，会产生不连续的内存空间碎片。

### 二维数组内存寻址

```
对于m*n的数组，a[i][j](i<m,j<n)的地址为
address = base_address + (i * n + j) * type_size
```

## 总结：

- 很多时候我们并不是要去死记硬背某个数据结构和算法，而是要学习它背后的思想和处理技巧，这些东西才是最有价值的。



# 06|链表（上）：如何实现LRU缓存淘汰算法？

## 什么是链表？

- 链表，通过”指针“将一组零散的内存块串联起来。
- 链表分类：单链表、双向链表、循环链表
- 第一个节点叫做头节点，把最后一个节点叫做为节点。
- 头节点用来记录链表的基地点。尾节点指针指向一个空地址NULL



## 如何使用单链表

### 插入节点：

- 时间复杂度O(1)
- 在链表的某个指定节点前面插入一个节点，时间复杂度O(n)，因为最耗时的是查找O(n)需要找到前驱节点

### 删除节点：

- 单纯的删除，时间复杂度O(1)
- 删除值等于给定值的节点，时间复杂度O(n)，因为最耗时的是查找O(n)需要找到前驱节点

### 查找：

- 时间复杂度O(n)



## 如何使用双向链表：（比单链表应用的更广泛）

### 插入节点：

- 时间复杂度O(1)，跟单链表比，找前驱节点时间复杂度变成O(1)

### 删除节点：

- 时间复杂度O(1)，跟单链表比，找前驱节点时间复杂度变成O(1)

### 查找：

- 比单链表高效，如果记录上次查找的位置p，每次查询可以根据查找值和p的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。



## 数组和链表对比

### 1、时间复杂度：相反

数组：插入删除O(n)、随机访问O(1)

链表：插入删除O(1)、随机访问O(n)

### 2、内存要求

数组：一组连续的内存空间，数组大小固定

链表：零散内存空间，天然动态扩容（与数组最大的区别）

### 3、预读数据

数组：连续的内存空间，可以借助CPU的缓存机制，预读数组中的数据，所以访问效率高

链表：不是连续存储，所以对CPU缓存不友好，没办法预读

（CPU读取一个数据块，CPU缓存的意义：为了弥补内存访问数据速度过慢与CPU执行速度快之间的差异而引入的）



## 课后思考：链表回文判断

- 快慢指针定位中间节点
- 从中间节点对后半部分逆序
- 前后半部分比较，判断是否为回文
- 后半部分逆序复原

时间复杂度O(n)，空间复杂度O(1)



## 拓展：

### 缓存淘汰策略(举例：书本清除)

- 先进先出策略FIFO（First In, First Out）
- 最少使用策略LFR（Least Frequently Used）
- 最近最少使用策略LRU（Least Recently Used）

### 约瑟夫环

- 适合用循环链表实现

### LinkedHashMap

- 用双向链表这种数据结构

### LinkedList

- 用双向链表这种数据结构