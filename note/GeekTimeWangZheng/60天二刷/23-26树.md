# 23 | 二叉树基础（上）

1、树

- 节点的高度=节点到叶子节点的最长路径（边数）
- 节点的深度=根节点到这个节点所经历的边的个数
- 节点的层数=节点的深度+1
- 树的高度=根节点的高度
- “高度”这个概念，其实就是从下往上度量；“深度”这个概念在生活中是从上往下度量的，从根结点开始度量；“层数”跟深度的计算类似，不过，计数起点是 1

2、二叉树

- 节点叉数最多为2，分为左节点和右节点
- 叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点，这种二叉树就叫作满二叉树
- 叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫作完全二叉树。
- 想要存储一棵二叉树，我们有两种方法，一种是基于指针或者引用的二叉链式存储法，一种是基于数组的顺序存储法
- 如果节点 X 存储在数组中下标为 i 的位置，下标为 2 * i 的位置存储的就是左子节点，下标为 2 * i + 1 的位置存储的就是右子节点（所以仅仅“浪费”了一个下标为 0 的存储位置）



# 24 | 二叉树基础（下）

1、二叉查找树（Binary Search Tree）

- 二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。
- 查找：比较节点，相等返回；小递归查找左子树，大递归查找右子树
- 插入：比较节点，如果大，看右节点是否为空，如果为空插入，否则递归右子树插入；如果小，看左节点是否为空，如果为空插入，否则递归左子树插入
- 删除：情况一：没有左右节点，直接删除；情况二：只有一个节点，更新父节点指向这个节点；情况三：两个节点，取右子树中最小的节点，就是右子树中最靠左的
- 中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是 O(n)，非常高效

2、二叉查找树的时间复杂度分析

- 时间复杂度其实都跟树的高度成正比，也就是 O(height)



# 25 | 红黑树（上）

1、什么是“平衡二叉查找树”？

- 平衡二叉树的严格定义是这样的：二叉树中任意一个节点的左右子树的高度相差不能大于 1。

2、红黑树

- 一棵红黑树还需要满足这样几个要求：根节点是黑色的；
- 每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；
- 任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；
- 每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；

3、红黑树近似平衡的

- “平衡”的意思可以等价为性能不退化。“近似平衡”就等价为性能不会退化的太严重。

4、总结

- 红黑树是一种平衡二叉查找树。它是为了解决普通二叉查找树在数据更新的过程中，复杂度退化的问题而产生的。红黑树的高度近似 log2n，所以它是近似平衡，插入、删除、查找操作的时间复杂度都是 O(logn)



# 26 | 红黑树（下）

1、调整的过程包含两种基础的操作：左右旋转和改变颜色。

2、总结：

第一点，把红黑树的平衡调整的过程比作魔方复原，不要过于深究这个算法的正确性。

第二点，找准关注节点，不要搞丢、搞错关注节点。

第三点，插入操作的平衡调整比较简单，但是删除操作就比较复杂。



# 27 | 递归树

实战一：分析快速排序的时间复杂度

- 快速排序在最好情况下，每次分区都能一分为二，这个时候用递推公式 T(n)=2T(2n)+n，很容易就能推导出时间复杂度是 O(nlogn)
- 这个快排过程遍历的数据个数就是 h∗n ，也就是说，时间复杂度就是 O(h∗n)

实战二：分析斐波那契数列的时间复杂度

- 如果路径长度都为 n，那这个总和就是 2n−1。

实战三：分析全排列的时间复杂度

- 这个公式的求和比较复杂，我们看最后一个数，n∗(n−1)∗(n−2)∗…∗2∗1 等于 n!





