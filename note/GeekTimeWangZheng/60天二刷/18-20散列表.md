# 18 | 散列表（上）

1、散列表定义

- 散列表用的是数组支持按照下标随机访问数据的特性，
- 键（key）或者关键字，转化为数组下标的映射方法就叫作散列函数（或“Hash 函数”“哈希函数”），而散列函数计算得到的值就叫作散列值

2、散列函数的要求

- 散列函数计算得到的散列值是一个非负整数；
- 如果 key1 = key2，那 hash(key1) == hash(key2)；
- 如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)。

3、散列冲突

3.1 开放寻址法

- 线性探测（Linear Probing），依次往后探测，探测步长是1
- 二次探测，步长就变成了原来的“二次方”，hash(key)+0，hash(key)+12，hash(key)+22……
- 双重散列，两个散列函数找到空闲的存储位置

3.2 链表法

- 散列函数计算出对应的散列槽位，将其插入到对应链表中即可



# 19 | 散列表（中）

1、设计散列函数的要求

- 散列函数的设计不能太复杂
- 散列函数生成的值要尽可能随机并且均匀分布
- 直接寻址法、平方取中法、折叠法、随机数法等

2、动态扩容

- 将扩容操作穿插在插入操作的过程中
- 装载因子触达阈值之后，我们只申请新空间
- 我们将新数据插入新散列表中，并且从老的散列表中拿出一个数据放入到新散列表

3、冲突解决办法

3.1 开放寻址法

- 优点：有效地利用 CPU 缓存加快查询速度、序列化起来比较简单
- 缺点：冲突代价更高，更易冲突
- 总结：当数据量比较小、装载因子小的时候，适合采用开放寻址法

3.2 链表法

- 优点：对大装载因子的容忍度更高；方便替换：将链表法中的链表改造为其他高效的动态数据结构，比如跳表、红黑树。
- 缺点：额外存储空间；不易序列化
- 总结：基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。



# 20 | 散列表（下）

1、LRU 缓存淘汰算法

- 散列表和双向链表同时使用
- 添加、删除、查找的时间复杂度都由O(n)变成O(1)

2、Redis 有序集合

- 按照分值将成员对象组织成跳表的结构
- 按照键值构建一个散列

3、Java LinkedHashMap

- LinkedHashMap 是通过双向链表和散列表这两种数据结构组合实现的。LinkedHashMap 中的“Linked”实际上是指的是双向链表，并非指用链表法解决散列冲突

4、散列表和链表结合

- 散列表这种数据结构虽然支持非常高效的数据插入、删除、查找操作，但是散列表中的数据都是通过散列函数打乱之后无规律存储的
- 所以每当我们希望按顺序遍历散列表中的数据的时候，将散列表和链表（或者跳表）结合在一起使用