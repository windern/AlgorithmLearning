# 11 | 排序（上）

1、如何分析一个排序算法？

（1）排序算法的执行效率（最好、最坏、平均时间复杂度；时间复杂度系统、低阶、常量；比较和交换次数）

（2）排序算法的内存消耗（空间复杂度，O(1)原地排序算法）

（3）算法稳定性（相等元素前后关系不变）

2、冒泡排序

- 相邻元素比较，满足大小关系交换
- 原地排序
- 稳定排序
- 时间复杂度：最好O(n)、最坏O(n^2)、平均O(n^2) - n*(n-1)/4次交换

3、插入排序

- 分为已排序区间、未排序区间，每次从未排序区间，插入一个值到已排序区间中，从后往前比较插入
- 原地排序
- 稳定排序
- 时间复杂度：最好O(n)、最坏O(n^2)、平均O(n^2) 

4、选择排序

- 分为已排序区间、未排序区间，每次从未排序区间取最小的值，放在已排序区间的末尾，做的是交换操作
- 原地排序
- 不稳定排序
- 时间复杂度：最好O(n^2)、最坏O(n^2)、平均O(n^2)

5、其他

- 冒泡排序比插入排序的数据移动复杂，操作要多
- 小规模排序，这三种算法用起来非常高效



# 12 | 排序（下）

1、归并排序

原理：

- 分治的思想，合并两个有序数组
- 如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。
- 归并排序使用的就是分治思想。分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。
- 排序一个数组，拆分成两个子数组，然后子数组排好序，然后合并两个有序的子数组

递推公式：

- merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1,r))
- 终止条件：p>=r 不能再继续分解了

代码实现：

- 核心函数merge合并两个有序数组，借助一个额外数组，然后依次比较拷贝，如果一个数组到底了，将剩下一个数组全部拷贝进去
- 核心函数merge_sort排序

性能分析：

- 稳定排序算法
- 非原地排序算法，空间复杂度O(n)
- 时间复杂度：最好、最坏、平均都是O(nlogn)

2、快速排序

原理：

- 选择分区点，将小的放在分区点左边，将大的放在分区点右边
- 如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）

递推公式：

- quick_sort(p,r) = quick_sort(p,q-1) + quick_sort(q+1,r)
- 终止条件：p>=r

代码实现：

- 我们通过游标 i 把 A[p…r-1] 分成两部分。A[p…i-1] 的元素都是小于 pivot 的，我们暂且叫它“已处理区间”，A[i…r-1] 是“未处理区间”。我们每次都从未处理的区间 A[i…r-1] 中取一个元素 A[j]，与 pivot 对比，如果小于 pivot，则将其加入到已处理区间的尾部，也就是 A[i] 的位置
- 核心点：i表示应该在的位置，i-1就是已处理区间，j作为循环，最后交换i和r

性能分析：

- 非稳定排序算法
- 原地排序算法
- 时间复杂度：最好O(nlogn)(及其均匀每次在中间)、最坏O(n^2)（每次都不均等）、平均O(nlogn)

3、第K大元素

- 利用快排的思想，第一次分区p；如果k=p，就找到了；如果k>p，则在[p+1,n]中间再排一次；如果k<p，则在[0,p-1]区间查找



# 13 | 线性排序

1、桶排序

- 核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。
- 整个桶排序的时间复杂度就是 O(n*log(n/m)) -  n 个数，m 个桶内
- 桶排序比较适合用在外部排序中。

2、计数排序

- 计数排序其实是桶排序的一种特殊情况。
- 计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了
- 核心思想：快速计算出数据在排序后的数组中的位置

3、基数排序

- 基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。
- 每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n)



# 14 | 排序优化

1、优化快速排序（最理想的分区点是：被分区点分开的两个分区中，数据的数量差不多）

- 三数取中法
- 随机法

2、小规模排序

- 在小规模数据面前，O(n2) 时间复杂度的算法并不一定比 O(nlogn) 的算法执行时间长
- 时间复杂度代表的是一个增长趋势
- 对于小数据量的排序，我们选择比较简单、不需要递归的插入排序算法