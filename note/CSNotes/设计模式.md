# 创建型

## 1、单例(Singleton)

- 懒汉模式（非线程安全）：用到的采取才实例化

- 饿汉模式（线程安全）：直接定义的时候实例化

- 懒汉线程安全模式（线程安全）：使用synchronized的函数级加锁

- 双重校验锁（线程安全）：一次判空，然后synchronized加锁代码，再判空，再实例化……使用volatile定义全局变量，防止指令重排

- 静态内部类实现（线程安全）：

  ```
  private static class SingletonHolder {
  	private static final Singleton INSTANCE = new Singleton();
  }
  ```

- 枚举实现（线程安全）：该实现可以防止反射攻击。在其它实现中，通过 setAccessible() 方法可以将私有构造函数的访问级别设置为public，然后调用构造函数从而实例化对象

## 2、简单工厂(Simple Factory)

- 创建对象不暴露创建细节，提供一个创建对象的通用接口。
- 简单工厂类决定创建哪个具体子类来实例化

## 3、工厂方法(Factory Method)

- 定义一个创建对象的接口，但是由子类来决定要实例化哪个类。工厂方法将实例化操作延迟到子类。
- 多个工厂，具体工厂来决定实例化哪个子类

## 4、抽象工厂(Abstract Factory)

- 提供一个接口，用于创建相关的对象家族
- 多个工厂方法接口，多个对象

## 5、生成器（Builder）

- 封装一个对象的封装过程，并允许其按步骤构造
- StringBuilder的append

## 6、原型模式(Prototype)

- 使用原型实例指定要创建对象的类型，通过复制这个原型来创建新对象



# 行为型

## 1、责任链模式（Chain Of Responsibility）

- 使多个对象都有机会处理请求，从而避免请求的发送者和接受者的耦合关系。将这些对象连成一个链，并沿着这条链发送该请求，直到有一个对象处理它为止。
- 多个接受者都可能处理，形成链，到谁那处理能处理就处理

## 2、命令（Command）

### Intent：

命令封装对象的作用

- 使用命令参数化其他对象
- 将命令放在队列中进行排队
- 将命令的操作写入到日志中
- 命令支持撤销

### Class Diagram:

- Recevier：命令接受者，也就是命令执行者
- Command：命令，Command包含Recevier，excute的时候调用Receiver中的方法执行
- Invoker：通过它来调用命令，Invoker包含Command，中间调度的一个工作
- Client：可以设置命令和命令接受者

## 3、解释器（Interpreter）

- 为语言创建解释器，通常由语言的语法和语法分析来定义
- TerminalExpression：终结表达式
- Context：上下文

## 4、迭代器模式（Iterator）

### Intent

- 提供一种顺序访问聚合对象元素的方法，并且不暴露聚合对象的内部表示

### Class Diagram

- Aggregate是聚合类，提供createIterator方法，返回Iterator
- Iterator主要定义hasNext()和next()方法

## 5、中介者模式（Mideator）

### Intent

- 集中相关对象之间复杂的沟通和控制方式

### Class Diagram

- Mediator：中介者，定义一个接口用于与各个同事（Colleague）通信
- Colleage：同事，相关对象
- 关键点：解耦了各个同事之间的操作联系，都通过Mediator进行沟通

## 6、备忘录（Memento）

### Intent

- 在不违反封装的情况下获取内部对象的状态，从而在需要时可以将对象恢复到最初的对象
- 关键点：提供可以保存的对象

### Class Diagram

- Originator：原始对象
- Caretaker：负责保存好备忘录
- Memento：备忘录，存储原始对象的状态。提供两个接口，一个给Caretaker的窄接口，一个给Originator的宽接口

## 7、观察者模式（Observer）

### Intent

- 定义对象之间一对多依赖，当一个对象状态改变时，他的所有依赖都会受到通知并且自动更新状态

### Class Diagram

- 主题（Subject）具有注册和移除观察者、并通知所有观察者的功能，主题通过维护一张观察者列表来实现操作的
- 观察者（Observer）的注册功能需要调用主题的registerObserver()方法，提供更新状态的方法

## 8、状态（state）

### Intent

- 允许对象在内部状态变化时改变他的行为，对象看起来好像修改了它所属的类

#### Class Diagram

- State状态（包含handle()方法），ConcreteState具体状态
- Context包含一个状态，执行state.handle()方法

## 9、策略模式（Strategy）

### Intent

- 定义一系列的算法，封装每个算法，并使它们可以互换
- 策略模式可以让算法独立于使用它的客户端

### Class Diagram

- Strategy接口定义一系列算法族，他们都实现了behavior()方法
- Context是使用到了该算法族的类，其中doSomething()方法会调用behavior()方法，setStrategy(Strategy)方法可以动态改变strategy对象，也就是说能动态地改变Context使用到的算法

#### 与状态模式的比较

状态模式的类图和策略模式类似，并且都是能够动态改变对象的行为。但是状态模式是通过状态转移来改变 Context所组合的 State 对象，而策略模式是通过 Context 本身的决策来改变组合的 Strategy 对象。所谓的状态转移，是指Context 在运行过程中由于一些条件发生改变而使得 State 对象发生改变，注意必须要是在运行过程中。

状态模式主要是用来解决状态转移的问题，当状态发生转移了，那么 Context 对象就会改变它的行为;而策略模式主 要是用来封装一组可以互相替代的算法族，并且可以根据需要动态地去替换 Context 使用的算法。

## 10、模板方法（Template Method）

- 定义算法框架，并将一些步骤的实现延迟到子类
- 通过模板方法，子类可以重新定义算法的某些步骤，而不用改变算法的结构

## 11、访问者（Visitor）

### Intent

- 为一组对象结构（比如组合结构）增加新功能

### Class Diagram

- ObjectStructure：对象结构，可以是组合结构，或者是一个集合
- Visitor：访问者，为每个ConcreteElement提供一个visit操作

## 12、空对象（NULL）

- 使用什么都不做的空对象代替NULL
- 如果返回NULL，需要做空指针检查，返回什么都不做的空对象，可以避免这种检查



# 结构型

## 1、适配器（Adapter）

- 把一个类的接口转换成另外一个用户需要的接口

## 2、桥接（Bridge）

### Intent

- 将抽象和实现分离开来，使它们可以独立变化

### Class Diagram

- Abstraction：定义抽象类的接口（例子：RemoteControl表示遥控器）
- Implementor：定义实现类的接口（例子：TV表示电视）

## 3、组合（Composite）

### Intent

- 将对象组合成树形结构来表示“部分/整体”层次关系，允许用户以相同的方式处理单独对象和组合对象

### Class Diagram

- 组件（Component）类是组合类（Composite）和叶子类（Leaf）的父类，可以把组合类看成树的中间节点

## 4、装饰（Decorator）

### Intent

- 为对象动态添加功能

### Class Diagram

- 装饰者（Decorator）和具体组件（ConcreteComponent）都继承组件（Component）
- 所谓装饰，就是装饰者套在被装饰者之上，从而动态扩展被装饰者的功能（丰富了装饰者的功能，提供了一些额外的逻辑）

## 5、外观（Facade）

### Intent

- 提供了一个统一的接口，用来访问子系统中的一群接口，从而让子系统更易使用

设计原则

- 最少知识原则

## 6、享元（Flyweight）

### Intent

- 利用共享的方式来支持大量细粒度的对象，这些对象一部分内部状态是相同的
- 缓存

## 7、代理（Proxy）

### Intent

- 控制对其他对象的访问

### Class Diagram

代理有一下四类：

- 远程代理
- 虚拟代理
- 保护代理
- 智能代理

