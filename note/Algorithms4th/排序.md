# 模板

- less(v, w) - 比较
- exch(a, i, j) - 交换



# 选择排序

## 核心点：

- 不断 - 选择 - 最小的
- 缺点：运行时间和输入无关，排序好的和随机的一样……与其它算法不同，没有用到初始状态
- 优点：数据移动次数最少的

## 时间复杂度

- N<sup>2</sup>/2次 比较 + N次 交换

## 总结：

#### 和冒泡排序的区别：

- 冒泡排序每次与相邻的交换，选择排序与当前项和第n项
- 查找过程一样，交换过程不一样
- 比较次数相同，冒泡每次都交换，选择排序交换次数更少
- 通常选择排序更快一点

## 代码关键点：

- min记录的是最小值的索引，并非值
- 比较选择的时候，是当前与最小的比，不要误写成和最前面的比（比较是a[j]和a[min]，不要误写成a[j]和a[i]）



# 插入排序

## 核心点：

- 不断 - 插入 - 前面排好序的数组
- 将a[i]插入到a[i-1]、a[i-2]……0的数组中，从后面不断的跟前面的比较，不断交换就能确定位置
- 对于数组 {3, 5, 2, 4, 1}，它具有以下逆序：(3, 2), (3, 1), (5, 2), (5, 4), (5, 1), (2, 1), (4, 1)，插入排序每次只能交换相邻元素，令逆序数量减少 1，因此插入排序需要交换的次数为逆序数量。
- 定理：交换的次数= 倒置数量，比较的次数 >= 倒置的数量、比较的次数 <= 倒置的数量 + 数组的大小 - 1
- 优点：倒置数量很少时，比任何算法都快
- 提高：结合选择排序，先只记录位置，较大元素右移，而不是总是交换

## 时间复杂度：

- 平均情况：插入排序需要 \~N<sup>2</sup>/4 比较以及 \~N<sup>2</sup>/4 次交换；
- 最坏的情况：需要 \~N<sup>2</sup>/2 比较以及 \~N<sup>2</sup>/2 次交换，最坏的情况是数组是倒序的；
- 最好的情况：需要 N-1 次比较和 0 次交换，最好的情况就是数组已经有序了。

## 场景：

- 部分有序
- 小规模数组