# 序

- 整理数据的第一步就是排序
- 快排被誉为20世纪科学和工程领域的是10大算法之一



# 模板

- less(v, w) - 比较
- exch(a, i, j) - 交换



# 选择排序

## 核心点：

- 不断 - 选择 - 最小的
- 缺点：运行时间和输入无关，排序好的和随机的一样……与其它算法不同，没有用到初始状态
- 优点：数据移动次数最少的

## 时间复杂度

- N<sup>2</sup>/2次 比较 + N次 交换

## 代码关键点：

- min记录的是最小值的索引，并非值
- 比较选择的时候，是当前与最小的比，不要误写成和最前面的比（比较是a[j]和a[min]，不要误写成a[j]和a[i]）

## 总结：

#### 和冒泡排序的区别：

- 冒泡排序每次与相邻的交换，选择排序与当前项和第n项
- 查找过程一样，交换过程不一样
- 比较次数相同，冒泡每次都交换，选择排序交换次数更少
- 通常选择排序更快一点





# 插入排序

## 核心点：

- 不断 - 插入 - 前面排好序的数组
- 将a[i]插入到a[i-1]、a[i-2]……0的数组中，从后面不断的跟前面的比较，不断交换就能确定位置
- 对于数组 {3, 5, 2, 4, 1}，它具有以下逆序：(3, 2), (3, 1), (5, 2), (5, 4), (5, 1), (2, 1), (4, 1)，插入排序每次只能交换相邻元素，令逆序数量减少 1，因此插入排序需要交换的次数为逆序数量。
- 定理：交换的次数= 倒置数量，比较的次数 >= 倒置的数量、比较的次数 <= 倒置的数量 + 数组的大小 - 1
- 提高：结合选择排序，先只记录位置，较大元素右移，而不是总是交换

## 时间复杂度：

- 平均情况：插入排序需要 \~N<sup>2</sup>/4 比较以及 \~N<sup>2</sup>/4 次交换；
- 最坏的情况：需要 \~N<sup>2</sup>/2 比较以及 \~N<sup>2</sup>/2 次交换，最坏的情况是数组是倒序的；
- 最好的情况：需要 N-1 次比较和 0 次交换，最好的情况就是数组已经有序了。

## 优缺点：

- 优点：倒置数量很少时，比任何算法都快

## 场景：

- 部分有序
- 小规模数组



# 希尔排序

## 核心点：

- 插入排序的升级
- 插入排序只会交换相邻的元素，为了加快速度，交换间隔为h的元素
- 对于大规模的数组，插入排序很慢，因为它只能交换相邻的元素，每次只能将逆序数量减少 1。希尔排序的出现就是为了解决插入排序的这种局限性，它通过交换不相邻的元素，每次可以将逆序数量减少大于 1。
- 希尔排序使用插入排序对间隔 h 的序列进行排序。通过不断减小 h，最后令 h=1，就可以使得整个数组是有序的。
- 希尔排序的运行时间达不到平方级别，使用递增序列 1, 4, 13, 40, ... 的希尔排序所需要的比较次数不会超过 N 的若干倍乘于递增序列的长度。后面介绍的高级排序算法只会比希尔排序快两倍左右。

## 时间复杂度：

- 数学上还不知道希尔排序所需要的平均比较词素
- 最坏情况的比较次数(N<sup>4/3</sup>,N<sup>5/4</sup>,N<sup>6/5</sup>...)

## 优缺点：

- 代码量小
- 不需要额外空间

## 场景：

- 中等大小的数组

## 代码关键点：

- i=h，并不从第一个开始
- 将a[i]插入到a[i-h]、a[i-2*h]、a[i-3*h]……的序列中
- for (int j = i; j - h >= 0 && less(a[j], a[j - h]); j -= h) 



# 归并排序

## 核心点：

- 将两个有序的数组 归并 成 一个更大的有序数组
- 所需额外空间与N成正比

## 自顶向下归并排序

- 将一个大数组分成两个小数组去求解。
- 递归
- 因为每次都将问题对半分成两个子问题，这种对半分的算法复杂度一般为 O(NlogN)。

## 自底向上归并排序

- 先归并那些微型数组，然后成对归并得到的微型数组。
- sz子数组的大小、lo子数组的索引
- lo的边界是 lo < n - sz
- lo增加的时候，lo = lo + sz + sz
- merge(nums, lo, lo + sz - 1, Math.min(lo + sz + sz - 1, N - 1));  要注意min防止越界

## 时间复杂度：

- 最坏的情况：NlgN

## 总结

- 归并排序是一种渐进最优的基于比较排序的算法
- 归并排序最坏情况下的比较次数和任意基于比较排序的排序算法所需的最少比较次数都是~NlgN
- 归并排序与希尔排序比差距在常数级别之类，相对性能取决于具体的实现