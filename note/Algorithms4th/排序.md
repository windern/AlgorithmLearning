# 模板

- less(v, w) - 比较
- exch(a, i, j) - 交换



# 选择排序

## 核心点：

- 不断 - 选择 - 最小的
- 缺点：运行时间和输入无关，排序好的和随机的一样……与其它算法不同，没有用到初始状态
- 优点：数据移动次数最少的

## 时间复杂度

- N<sup>2</sup>/2次 比较 + N次 交换

## 代码关键点：

- min记录的是最小值的索引，并非值
- 比较选择的时候，是当前与最小的比，不要误写成和最前面的比（比较是a[j]和a[min]，不要误写成a[j]和a[i]）

## 总结：

#### 和冒泡排序的区别：

- 冒泡排序每次与相邻的交换，选择排序与当前项和第n项
- 查找过程一样，交换过程不一样
- 比较次数相同，冒泡每次都交换，选择排序交换次数更少
- 通常选择排序更快一点





# 插入排序

## 核心点：

- 不断 - 插入 - 前面排好序的数组
- 将a[i]插入到a[i-1]、a[i-2]……0的数组中，从后面不断的跟前面的比较，不断交换就能确定位置
- 对于数组 {3, 5, 2, 4, 1}，它具有以下逆序：(3, 2), (3, 1), (5, 2), (5, 4), (5, 1), (2, 1), (4, 1)，插入排序每次只能交换相邻元素，令逆序数量减少 1，因此插入排序需要交换的次数为逆序数量。
- 定理：交换的次数= 倒置数量，比较的次数 >= 倒置的数量、比较的次数 <= 倒置的数量 + 数组的大小 - 1
- 提高：结合选择排序，先只记录位置，较大元素右移，而不是总是交换

## 时间复杂度：

- 平均情况：插入排序需要 \~N<sup>2</sup>/4 比较以及 \~N<sup>2</sup>/4 次交换；
- 最坏的情况：需要 \~N<sup>2</sup>/2 比较以及 \~N<sup>2</sup>/2 次交换，最坏的情况是数组是倒序的；
- 最好的情况：需要 N-1 次比较和 0 次交换，最好的情况就是数组已经有序了。

## 优缺点：

- 优点：倒置数量很少时，比任何算法都快

## 场景：

- 部分有序
- 小规模数组



# 希尔排序

## 核心点：

- 插入排序的升级
- 插入排序只会交换相邻的元素，为了加快速度，交换间隔为h的元素
- 对于大规模的数组，插入排序很慢，因为它只能交换相邻的元素，每次只能将逆序数量减少 1。希尔排序的出现就是为了解决插入排序的这种局限性，它通过交换不相邻的元素，每次可以将逆序数量减少大于 1。
- 希尔排序使用插入排序对间隔 h 的序列进行排序。通过不断减小 h，最后令 h=1，就可以使得整个数组是有序的。
- 希尔排序的运行时间达不到平方级别，使用递增序列 1, 4, 13, 40, ... 的希尔排序所需要的比较次数不会超过 N 的若干倍乘于递增序列的长度。后面介绍的高级排序算法只会比希尔排序快两倍左右。

## 时间复杂度：

- 数学上还不知道希尔排序所需要的平均比较词素
- 最坏情况的比较次数(N<sup>4/3</sup>,N<sup>5/4</sup>,N<sup>6/5</sup>...)

## 优缺点：

- 代码量小
- 不需要额外控件

## 场景：

- 中等大小的数组